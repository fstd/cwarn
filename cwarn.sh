#!/bin/sh

optvars="
	'slaves:s:slaves@path to file containing lines with ips and ports of the build slaves'
	'std:c:c99@standard to pretend the input used (c89, c99, c11)'
	'cc:c:gcc@compiler to use for guessing the standard'
"

argvars="
	'url@input filename (file is generated by cid.sh)'
	'outfile@output filename (to save a copy as)'
"


Main()
{
	# ------------------------- cid -------------------------------
	tmp=$(TF)
	inp=$(TF)

	curl -s "$url" >"$tmp" 

	[ -s "$tmp" ] || { echo "BAD EMPTY"; exit 0; }

	printf '\n' >>"$tmp" #swallowed at least on codepad
	tr -d '\r' <"$tmp" >"$inp" #tendra chokes on \r\n endings as some pastebins produce

	file "$inp" | grep -q 'HTML\|XML' && { echo "BAD MARKUP"; exit 0; }

	grep -qF ';' "$inp" || { echo "BAD NOTC"; exit 0; }

	if [ "$std" = "auto" ]; then
		std="$(GuessStd "$inp")"
		D "I guess this is '$std'"
	fi

	cat <"$inp" >"$outfile"

	jobs=$(TF)

	for f in $(grep -v '^#' $slaves | grep -v "^[ $TAB]*\$" | sed 's/  */:/'); do
		tmp=$(TF)
		host="$(echo "$f" | cut -d : -f 1)"
		port="$(echo "$f" | cut -d : -f 2)"
		res="res_$(printf '%s-%s' "$host" "$port")"
		printf 'BEGIN %s\n%s\nEND\n' "$std" "$(sed 's/^/DATA /' "$inp")" >$tmp
		nc "$host" "$port" >"$res" <$tmp &
		printf '%s %s\n' "$!" "$res" >>$jobs
	done

	timeout=$(($(date +%s)+10))

	# no wait(1) here because we don't want to potentially wait forever
	while true; do
		if [ $(date +%s) -gt $timeout ]; then
			cut -d ' ' -f 1 $jobs | xargs kill -TERM 2>/dev/null
			break
		fi

		notfin=
		for pid in $(cut -d ' ' -f 1 $jobs); do
			if kill -s 0 $pid 2>/dev/null; then
				notfin=1
				break;
			fi
		done

		if [ -z "$notfin" ]; then
			break;
		fi

		sleep 1
	done

#	rm -f r_*.res r_output "$inp".lnum #ew. XXX
#
#	export c=0
#	cat $(cut -d ' ' -f 2 $jobs) | while read -r cmd rest; do
#		case "$cmd" in
#			BEGIN) c=$((c+1)); trg="r_${c}.res"; printf '%s\n' "$rest" >>$trg ;;
#			DATA) printf '%s\n' "$rest" >>$trg ;;
#			*) ;;
#		esac
#	done
#	
#	okay=0 nocomp=0 warnc=0 nolink=0 warnl=0 total=0
#	for f in r_*.res; do
#		status=$(head -n1 "$f" | cut -d ' ' -f 1)
#		case "$status" in
#			NOCOMPILE) nocomp=$((nocomp+1)) ;;
#			WARNEDC) warnc=$((warnc+1)) ;;
#			NOLINK) nolink=$((nolink+1)) ;;
#			WARNEDL) warnl=$((warnl+1)) ;;
#			OKAY) okay=$((okay+1)) ;;
#		esac
#		total=$((total+1))
#	done
#	
#	#add line numbers the too-lazy-to-properly-learn-awk way
#	export c=1
#	
#	printf '\n\n\n--------------------------------------------\n' >"$inp".lnum
#	printf 'Original program:\n\n' >>"$inp".lnum
#	sed 's/^/-/' "$inp" | while read -r ln; do
#		printf '%s\t%s\n' $c "${ln#-}"
#		c=$((c+1))
#	done >>"$inp".lnum
#	printf '\n--------------------------------------------\n' >>"$inp".lnum
#	
#	all="$( ( for f in r_*.res; do cat "$f"; printf '\n\n'; done ; cat "$inp".lnum ) | curl -s -F 'sprunge=<-' http://sprunge.us)"
#	
#	if [ $okay -eq $total ]; then
#		D "all good!"
#		printf 'OKAY\n%s\n' "$all"
#		exit 0 #everything great
#	fi
#	
#	#don't be overly pedantic, some "testcases" lack a main
#	if [ $((nocomp+warnc)) -eq 0 ]; then
#		D "all semi-good!"
#		printf 'OKAY\n%s\n' "$all"
#		exit 0 #meh
#	fi
#	
#	if [ $nocomp -gt 0 ]; then
#		cand="$(GetBiggest NOCOMPILE)"
#	elif [ $warnc -gt 0 ]; then
#		cand="$(GetBiggest WARNEDC)"
#	elif [ $nolink -gt 0 ]; then
#		cand="$(GetBiggest NOLINK)"
#	elif [ $warnl -gt 0 ]; then
#		cand="$(GetBiggest WARNEDL)"
#	else
#		rm -f "$jobs"
#		E "huh? $okay $nocomp $warnc $nolink $warnl $total"
#	fi
#	
#	sed 1d "$cand" >r_output
#	if ! [ -s r_output ] ; then
#		rm -f "$jobs"
#		E "output empty?"
#	fi
#	
#	printf 'Info: %s\n' "$(head -n1 $cand)" >>"$inp".lnum
#	one="$(cat r_output "$inp".lnum | curl -s -F 'sprunge=<-' http://sprunge.us)"
#	
#	printf '%s\n%s\n%s\n' "$(head -n1 $cand | cut -d ' ' -f 1)" "$one" "$all"

	cut -d ' ' -f 2 $jobs | xargs cat >$tmp

	if ! [ -s $tmp ]; then
		printf 'NO BUILDERS\n'
		exit 1
	fi

	cat $tmp

	return 0
}

GuessStd()
{
	err=$(TF)
	errfirst=$(TF)
	gotfirst=false
	src="$1"
	ret=DUNNO
	for e in 'c89 c99 c11' 'gnu89 gnu99 gnu11'; do
	for f in '-pedantic-errors' '-pedantic' ''; do
	for g in $e; do
		D "Trying $cc -std=$g $f -o /dev/null -c \"$src\""
		$cc -std=$g $f -o /dev/null $d "$src" >/dev/null 2>$err </dev/null
		ccret=$?
		if ! $gotfirst; then
			cat $err >$errfirst
			gotfirst=true
		fi

		if [ $ccret -eq 0 ]; then
			if [ "$g" = "c89" ] && grep -q 'mixed decl' $err; then
				D "meh"
				# hack: mixed decl and code -> c99 even
				# though gcc accepts it in c89 mode
				continue
			fi
			D "yes."

			ret="$g"
			break 3
		else
			D "no"
		fi
	done
	done
	done

	if [ "$ret" = "DUNNO" ]; then
		if grep -qF 'stray' $errfirst && grep -q 'missing\|expected' $errfirst && \
		    [ $(wc -l <"$src") -ge $(printf '%s*0.75\n' $(wc -l <"$src") | bc -l | sed 's/\..*$//') ]; then
			W "this is probably not C"
			ret="GARBAGE"
		fi
	fi

	echo "$ret" | sed 's/gnu/c/'
}


GetBiggest()
{
	type="$1"
	set -x
	max=0
	cand=
	for f in $(grep -l "^$type" r_*.res); do
		nl=$(wc -l <$f)
		if [ $nl -gt $max ]; then
			max=$nl
			cand="$f"
		fi
	done
set +x

	printf '%s\n' "$cand"
}

prgauthor='Timo Buhrmester'
prgyear=2015
prgcontact='#fstd on irc.freenode.org'

#Available: D(), W(), E(), Usage()

. shboil.inc.sh
