#!/bin/sh

optvars="
	'slaves:s:@path to file containing lines with ips and ports of the build slaves'
	'std:c:c99@standard to pretend the input used (c89, c99, c11)'
"

argvars="
	'inp@input filename (file is generated by cid.sh)'
"

Main()
{
	if ! [ -f "$inp" -a -s "$inp" ]; then
		E "empty?!"
	fi

	jobs=$(Tempfile)

	for f in $(grep -v '^#' $slaves | grep -v "^[ $TAB]*\$" | sed 's/  */:/'); do
		host="$(echo "$f" | cut -d : -f 1)"
		port="$(echo "$f" | cut -d : -f 2)"
		res="res_$(printf '%s-%s' "$host" "$port")"
		printf 'BEGIN %s\n%s\nEND\n' "$std" "$(sed 's/^/DATA /' "$inp")" >$tmp
		nc "$host" "$port" >"$res" <$tmp &
		printf '%s %s\n' "$!" "$res" >>$jobs
	done

	timeout=$(($(date +%s)+10))

	# no wait(1) here because we don't want to potentially wait forever
	while true; do
		if [ $(date +%s) -gt $timeout ]; then
			cut -d ' ' -f 1 $jobs | xargs kill -TERM 2>/dev/null
			break
		fi

		notfin=
		for pid in $(cut -d ' ' -f 1 $jobs); do
			if kill -s 0 $pid 2>/dev/null; then
				notfin=1
				break;
			fi
		done

		if [ -z "$notfin" ]; then
			break;
		fi

		sleep 1
	done

#	rm -f r_*.res r_output "$inp".lnum #ew. XXX
#
#	export c=0
#	cat $(cut -d ' ' -f 2 $jobs) | while read -r cmd rest; do
#		case "$cmd" in
#			BEGIN) c=$((c+1)); trg="r_${c}.res"; printf '%s\n' "$rest" >>$trg ;;
#			DATA) printf '%s\n' "$rest" >>$trg ;;
#			*) ;;
#		esac
#	done
#	
#	okay=0 nocomp=0 warnc=0 nolink=0 warnl=0 total=0
#	for f in r_*.res; do
#		status=$(head -n1 "$f" | cut -d ' ' -f 1)
#		case "$status" in
#			NOCOMPILE) nocomp=$((nocomp+1)) ;;
#			WARNEDC) warnc=$((warnc+1)) ;;
#			NOLINK) nolink=$((nolink+1)) ;;
#			WARNEDL) warnl=$((warnl+1)) ;;
#			OKAY) okay=$((okay+1)) ;;
#		esac
#		total=$((total+1))
#	done
#	
#	#add line numbers the too-lazy-to-properly-learn-awk way
#	export c=1
#	
#	printf '\n\n\n--------------------------------------------\n' >"$inp".lnum
#	printf 'Original program:\n\n' >>"$inp".lnum
#	sed 's/^/-/' "$inp" | while read -r ln; do
#		printf '%s\t%s\n' $c "${ln#-}"
#		c=$((c+1))
#	done >>"$inp".lnum
#	printf '\n--------------------------------------------\n' >>"$inp".lnum
#	
#	all="$( ( for f in r_*.res; do cat "$f"; printf '\n\n'; done ; cat "$inp".lnum ) | curl -s -F 'sprunge=<-' http://sprunge.us)"
#	
#	if [ $okay -eq $total ]; then
#		D "all good!"
#		printf 'OKAY\n%s\n' "$all"
#		exit 0 #everything great
#	fi
#	
#	#don't be overly pedantic, some "testcases" lack a main
#	if [ $((nocomp+warnc)) -eq 0 ]; then
#		D "all semi-good!"
#		printf 'OKAY\n%s\n' "$all"
#		exit 0 #meh
#	fi
#	
#	if [ $nocomp -gt 0 ]; then
#		cand="$(GetBiggest NOCOMPILE)"
#	elif [ $warnc -gt 0 ]; then
#		cand="$(GetBiggest WARNEDC)"
#	elif [ $nolink -gt 0 ]; then
#		cand="$(GetBiggest NOLINK)"
#	elif [ $warnl -gt 0 ]; then
#		cand="$(GetBiggest WARNEDL)"
#	else
#		rm -f "$jobs"
#		E "huh? $okay $nocomp $warnc $nolink $warnl $total"
#	fi
#	
#	sed 1d "$cand" >r_output
#	if ! [ -s r_output ] ; then
#		rm -f "$jobs"
#		E "output empty?"
#	fi
#	
#	printf 'Info: %s\n' "$(head -n1 $cand)" >>"$inp".lnum
#	one="$(cat r_output "$inp".lnum | curl -s -F 'sprunge=<-' http://sprunge.us)"
#	
#	printf '%s\n%s\n%s\n' "$(head -n1 $cand | cut -d ' ' -f 1)" "$one" "$all"

	cut -d ' ' -f 2 $jobs | xargs cat

	return 0
}

GetBiggest()
{
	type="$1"
	set -x
	max=0
	cand=
	for f in $(grep -l "^$type" r_*.res); do
		nl=$(wc -l <$f)
		if [ $nl -gt $max ]; then
			max=$nl
			cand="$f"
		fi
	done
set +x

	printf '%s\n' "$cand"
}

prgauthor='Timo Buhrmester'
prgyear=2015
prgcontact='#fstd on irc.freenode.org'

#Available: D(), W(), E(), Usage()

. shboil.inc.sh
